[{"title":"JAVA面试","path":"/2023/03/06/JAVA面试/","content":"JAVASE面试题算法篇一、查找二分查找 前提：有序数组 A 定义左边界L、右边界R，确定搜索范围，循环执行3、4步 获取中间索引 M &#x3D; （L+R）&#x2F;2 中间索引的值 A[M] 与待搜索的值 T 进行比较 A[M] &#x3D; T 表示找到，返回中间索引 A[M] &gt; T，中间值右侧的其他元素都大于T，无需比较，中间索引左边寻找，M - 1设置为右边界，重新查找 A[M] &lt; T，中间值左侧的其他元素都小于T，无需比较，中间索引右边寻找，M + 1设置为左边界，重新查找 当 L &gt; R 时，表示没有找到，结束循环 1234567891011121314public int binarySearch(int[] a,int t)&#123; int l = 0,r = a.length - 1,m; while(l &lt;= r)&#123; m = (l+r) / 2; if(a[m]==t)&#123; return m; &#125;else if(a[m] &gt; t)&#123; r = m - 1; &#125;else&#123; l = m + 1; &#125; &#125; return -1;&#125; 基础篇一、自增变量12345678910public static void main(String[] args) &#123; int i = 1; i = i++; int j = i++; int k = i + ++i * i++; System.out.println(&quot;i=&quot; + i); System.out.println(&quot;j=&quot; + j); System.out.println(&quot;k=&quot; + k); &#125;i=4,j=1,k=11 1执行 i = i++; 先将i变量压入操作数栈，然再对i变量进行自增,最后把计算结果赋值给 i , i 任然是1 小结 赋值&#x3D;，最后计算 &#x3D;右边的从左到右加载值依次压入操作数栈 实际先算哪个，看运算符优先级 自增、自减操作都是直接修改变量的值，不经过操作数栈 最后的赋值之前，临时结果也是存储在操作数栈中 二、类初始化和实例初始化12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.classLoader;/** * 父类初始化&lt;clinit&gt; * 1、j = method() * 2、父类的静态代码块 * * 父类实例化方法: * 1、super()（最前） * 2、i = test() (9) * 3、父类的非静态代码块 (3) * 4、父类的无参构造（最后）(2) * * * 非静态方法前面其实有一个默认的对象this * this在构造器或&lt;init&gt; 他表示的是正在创建的对象，因为这里 * 是正在创建Son对象，所以test()执行的就是子类重写的代码(面 * 向对象多态) * * 这里i=test() 执行的就是子类重写的test()方法 */public class Father &#123; private int i = test(); private static int j = method(); static&#123; System.out.println(&quot;(1)&quot;); &#125; Father() &#123; System.out.println(&quot;(2)&quot;); &#125; &#123; System.out.println(&quot;(3)&quot;); &#125; public int test()&#123; System.out.println(&quot;(4)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(5)&quot;); return 1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.classLoader;/** * 子类的初始化&lt;clinit&gt; * 1、j = method() * 2、子类的静态代码块 * * 先初始化父类 (5)(1) * 初始化子类 (10) (6) * * 子类实例化方法: * 1、super()（最前） * 2、i = test() (9) * 3、子类的非静态代码块 (8) * 4、子类的无参构造（最后）(7) * * 因为创建了两个Son对象，因此实例化方法&lt;init&gt;执行两次 */public class Son extends Father &#123; private int i = test(); private static int j = method(); static &#123; System.out.println(&quot;(6)&quot;); &#125; Son() &#123; super();//写或不写，在子类构造器中一定会调用父类的构造器 System.out.println(&quot;(7)&quot;); &#125; &#123; System.out.println(&quot;(8)&quot;); &#125; public int test()&#123; System.out.println(&quot;(9)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(10)&quot;); return 1; &#125; public static void main(String[] args) &#123; Son son = new Son(); System.out.println(); Son son1 = new Son(); &#125;&#125;//结果：//(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)//(9)(3)(2)(9)(8)(7) 类初始化过程 一个类要创建实例需要先加载并初始化该类 ​\tmain方法所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行()方法 ​\t()方法由静态类变量显示赋值代码和静态代码块组成 ​\t类变量显示赋值代码和静态代码块代码从上到下顺序执行 ​\t()方法只执行一次 实例初始化过程实例初始化就是执行()方法 ​\t()方法可能重载多个，有几个构造器就有几个()方法 ()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行 每次创建实例对象，调用对应构造器，执行的就是对应的()方法 ()方法的首行是super()或super(实参列表)，即对应父类的()方法 方法的重写1、哪些方法不可以被重写 ​\tfinal方法 ​\t静态方法 ​\tprivate等子类中不可见方法 2、对象的多态性 ​\t子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码 ​\t非静态方法默认的调用对象是this ​\tthis对象在构造器或者说方法中就是正在创建的对象 重写与重载的区别 名称 发生范围 方法名 形参列表 返回类型 修饰符 重写 父子类 必须一样 相同 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 子类方法不能缩小父类方法的访问范围 重载 本类 必须一样 类型，个数或者顺序至少有一个不同 无要求 无要求 三、集合ArrayList1、扩容机制 ​\tArrayList() 会使用长度为零的数组 ​\tArrayList(int initialCapacity) 会使用指定容量的数组 ​\tArrayList(Collection&lt;? extends E&gt; c) 会使用c的大小作为数组容量 ​\tadd(Object o) 首次扩容为10，再次扩容为上次容量的1.5倍 ​\taddAll(Collection c)没有元素时，扩容为Math.max（10，c的长度），有元素时为Math.max（原容量的1.5倍，原容量加上c的长度） 12345678910111213if (minCapacity - elementData.length &gt; 0) grow(minCapacity);private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 2、fail-fast 与 fail-safe ​\tArrayList是fail-fast的典型代表，遍历的同时不能修改，尽快失败 ​\tCopyOnWriteArrayList 是fail-safe的典型代表，遍历的同时可以修改，原理是读写分离。 LinkedListArrayList 与 LinkedList ArrayList 基于数组，需要连续内存 随机访问快（指根据下标访问） 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，性能低 可以利用 cpu 缓存 LinkedList 基于双向链表，无需连续内存 随机访问慢（要沿着链表遍历） 头尾插入删除性能高 占用内存多 HashMap1、底层数据结构 ​\t1.7：数组+链表，头插法 ​\t1.8：数组+（链表|红黑树），尾插法 2、为何要用红黑树，为何一上来不树化，树化阈值为何是8，何时会树化，何时会退化为链表? ​\t红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况 ​\thash 表的查找，更新的时间复杂度是0(1)，而红黑树的查找，更新的时间复杂度是0(log n),TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表。 ​\thash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是0.00000006，选择8就是为了让树化几率足够小。 ​\t树化两个条件:链表长度超过树化阈值（8）;数组容量&gt;&#x3D;64​\t退化情况1:∶在扩容时如果拆分树时，树元素个数&lt;&#x3D;6则会退化链表，​\t退化情况2: remove树节点时，若root、root.left、root.right、root.left.left有一个为null，也会\t退化为链表 3、扩容：当容量大于数组容量的0.75时，2倍扩容 4、索引如何计算? hashCode都有了，为何还要提供 hash() 方法?数组容量为何是2的n次幂? ​\t① 计算对象的hashcode()，再进行调用 HashMap 的 hash()方法进行二次哈希，最后&amp; (capacity - 1)得到索引​\t② 二次hash()是为了综合高位数据，让哈希分布更为均匀​\t③ 计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高;扩容时 hash &amp; oldcap&#x3D;-0的元素留在原来位置，否则新位置&#x3D;旧位置+oldcap​\t④但①、②、③都是为了配合容量为2的n次幂时的优化手段，例如 Hashtable 的容量就不是2的n次幂，并不能说哪种设计更优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量 put方法①HashMap是懒惰创建数组的，首次使用才创建数组 ②计算索引(桶下标)③如果桶下标还没人占用，创建Node占位返回 ④如果桶下标已经有人占用 ①已经是TreeNode走红黑树的添加或更新逻辑 ②是普通Node,走链表的添加或更新逻辑，如果链表长 度超过树化阈值，走树化逻辑⑤返回前检查容量是否超过阈值，一旦超过进行扩容 ⑥不同 ①链表插入节点时，1.7是头插法，1.8是尾插法 ②1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容 ③1.8在扩容计算Node 索引时，会优化 加载因子为何默认是0.75f 在空间占用与查询时间之间取得较好的权衡 大于这个值，空间节省了，但链表就会比较长影响性能 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多 多线程下会有啥问题? 扩容死链（1.7) 数据错乱（1.7，1.8) key 能否为null，作为key的对象有什么要求? HashMap 的key可以为null，但Map的其他实现则不然 作为key的对象，必须实现 hashCode和equals，并且 key的内容不能修改(不可变) String对象的hashCode()如何设计的，为啥每次乘的是31目标是达到较为均匀的散列效果，每个字符串的hashCode足够独特 字符串中的每个字符都可以表现为一个数字，称为Si，其中i的范围是0~n- 1 散列公式为:S0 * 31^(n-1)+S1* 31^(n-2)+… Si * 31^(n-1-i) + … Sn-1*31^0 31代入公式有较好的散列特性，并且31 *h可以被优化为 即32 * h - h 即25 * h - h 即h &lt;&lt;5 -h 四、设计模式单例模式什么是单例模式？​ 单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。 要点 某个类只能有一个实例：构造器私有化 它必须自行创建这个实例：含有一个该类的静态变量来保存这个唯一的实例 它必须自行向整个系统提供这个实例：对外提供获取该实例对象的方式：(1）直接暴露（2）用静态变量的get方法获取 懒汉式：直接创建对象，不存在线程安全问题​\t直接实例化饿汉式（简洁直观） 123456789101112131415161718/** * 饿汉式： * 在类初始化时直接创建实例对象，不管你是否需要对象都会创建 * * (1)构造器私有化 * (2)自行创建，并且用静态变量保存 * (3)向外提供这个实例 * (4)强调这是一个单例，用final修饰 */public class HungrySingleton &#123; public static final HungrySingleton INSTANCE = new HungrySingleton(); private HungrySingleton()&#123; &#125;&#125; 枚举式（最简洁） 123456789package singleton.hungry;/** * 枚举类型：表示该类型的对象是有限的几个 * 我们可以限定为一个，就成了单例 */public enum EnumSingleton &#123; INSTANCE&#125; 静态代码块（适合复杂实例化） 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;import java.util.Properties;public class StaticCodeBlock &#123; public static final StaticCodeBlock INSTANCE; private String info; static &#123; try &#123; Properties pro = new Properties(); pro.load(StaticCodeBlock.class.getClassLoader().getResourceAsStream(&quot;singleton.properties&quot;)); INSTANCE = new StaticCodeBlock(pro.getProperty(&quot;info&quot;)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private StaticCodeBlock(String info)&#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; @Override public String toString() &#123; return &quot;StaticCodeBlock&#123;&quot; + &quot;info=&#x27;&quot; + info + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 懒汉式：延迟创建对象线程不安全（适用于单线程） 1234567891011121314151617181920/** * 懒汉式： * 延迟创建这个实例对象 * * （1）构造器私有化 * （2）用一个静态变量保存这个唯一的实例 * （3）提供一个静态方法，获取这个实例对象 */public class LazySingleton &#123; private static LazySingleton instance; private LazySingleton()&#123; &#125; public static LazySingleton getInstance()&#123; if(instance == null)&#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 线程安全（使用于多线程） 123456789101112131415161718192021222324/** * 懒汉式： * 延迟创建这个实例对象 * * （1）构造器私有化 * （2）用一个静态变量保存这个唯一的实例 * （3）提供一个静态方法，获取这个实例对象 */public class LazySingletonSynchronized &#123; private static volatile LazySingletonSynchronized instance; //volatile解决共享变量的可见性，有序性 private LazySingletonSynchronized()&#123; &#125; public static LazySingletonSynchronized getInstance()&#123; //双检锁 if (instance == null) &#123; synchronized (LazySingletonSynchronized.class) &#123; if (instance == null) &#123; instance = new LazySingletonSynchronized(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类（使用于多线程） 12345678910111213141516/** * 在内部类被加载和初始化时，才创建INSTANCE实例对象 * 静态内部类不会自动随着外部类的加载和初始化而初始化，它是单独去加载和初始化的。 * 因为是在内部类加载和初始化时创建，因此线程安全 */public class LazySingletonInnerclass &#123; private LazySingletonInnerclass()&#123; &#125; private static class Inner&#123; private static final LazySingletonInnerclass INSTANCE= new LazySingletonInnerclass(); &#125; public static LazySingletonInnerclass getInstance()&#123; return Inner.INSTANCE; &#125;&#125; 破坏单例 反射（枚举类不会破坏） 反序列化（①若重写readResolve方法，不会破坏。②枚举类也不会破坏） Unsafe()方法 小结​\t如果是饿汉式，枚举形式最简单 ​\t如果是懒汉式，静态内部类形式最简单 并发一、线程状态 二、线程池核心参数 1、corePoolSize 核心线程数目 ​\t最多保留的线程数 2、maximumPoolSize 最大线程数目 ​\t核心线程 + 救急线程 3、keepAliveTime 生存时间 ​\t针对救急线程 4、unit 时间单位 ​\t针对救急线程 5、workQueue ​\t阻塞队列 6、threadFactory 线程工厂 ​\t可以为线程创建时起个好名字 7、handler 拒绝策略 ​\t四种","tags":["JAVA面试"],"categories":["JAVA面试"]},{"title":"Little T","path":"/about/index.html","content":"TRT"}]