[{"title":"Mysql","path":"/2023/04/13/Mysql/","content":"Mysql一、Mysql索引MySQL中索引分三类:B+树索引、Hash索引、全文索引 InnoDB索引与MyISAM索引实现的区别是什么?MylSAMMylSAM索引文件和数据文件是分离的，使用B+树实现，主键索引和辅助索引实现一致，索引文件仅保存记录所在页的指针(物理位置)，通过这些地址来读取页，进而读取被索引的行。 lnnoDB的辅助索引data域存储相应记录主键的值而不是地址。 InnoDB的数据文件本身就是主索引文件。 MylSAM的索引和数据是分开存储的。","tags":["Mysql"],"categories":["Mysql"]},{"title":"Redis","path":"/2023/04/06/Redis/","content":"Redis一、Redis单线程与多线程Redis 6.0版本之前的单线程指的是其网络l&#x2F;O和键值对读写是由一个线程完成的Redis6.0引入的多线程指的是网络请求过程采用了多线程，而键值对读写命令仍然是单线程处理的，所以Redis依然是并发安全的也就是只有网络请求模块和数据操作模块是单线程的，而其它的持久化、集群数据同步等，其实是由额外的线程执行的 二、Redis快的原因1、命令执行基于内存操作，一条命令在内存里操作的时间是几十纳秒 2、命令执行是单线程操作，没有线程切换开销3、基于IO多路复用机制提升Redis的I&#x2F;O利用率4、高效的数据存储结构:全局hash表以及多种高效数据结构，比如:跳表，压缩列表，链表等等 三、Redis底层数据是如何用跳表来存储的跳表：将有序链表改造为支持近似”折半查找”算法，可以进行快速的插入、删除、查找操作 四、Redis Key过期了为什么内存没释放导致这个问题的原因在于:SET命令如果不设置过期时间，那么Redis会自动擦除这个key的过期时间如果你发现Redis 的内存持续增长，而且很多key原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。这时你的 Redis中就会存在大量不过期的key，消耗过多的内存资源所以，你在使用SET命令时，如果刚开始就设置了过期时间，那么之后修改这个key，也务必要加上过期时间的参数，避免过期时间丢失问题 Redis对于过期key的处理一般有惰性删除和定时删除两种策略1、惰性删除:当读&#x2F;写一个已经过期的key时，会触发惰性删除策略，判断key是否过期，如果过期了直接删除掉这个key 2、定时删除:由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批已过期的key,这里的一批只是部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放 五、Redis Key没设置过期时间为什么被Redis主动删除了当Redis已用内存超过maxmemory限定时，触发主动清理策略主动清理策略在Redis 4.0之前一共实现了6种内存淘汰策略，在4.0之后，又增加了2种策略，总共8种: a)针对设置了过期时间的key做处理: volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。 volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。 volatile-Iru：会使用LRU算法筛选设置了过期时间的键值对删除。 volatile-lfu：会使用LFU算法筛选设置了过期时间的键值对删除。 b)针对所有的key做处理: allkeys-random:从所有键值对中随机选择并删除数据。 allkeys-Iru:使用LRU算法在所有数据中进行筛选删除。 allkeys-lfu:使用LFU算法在所有数据中进行筛选删除。 c)不处理: noeviction:不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error)OOM command not allowed whenused memory”，此时Redis只响应读操作。 Redis淘汰Key的算法LRU与LFU区别LRU算法(Least Recently Used，最近最少使用):淘汰很久没被访问过的数据，以最近一次访问时间作为参考 LFU算法(Least Frequently Used，最不经常使用):淘汰最近一段时间被访问次数最少的数据，以次数作为参考绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点 六、Redis主从、哨兵、集群架构优缺点比较在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率 redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵·也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。 七、Redis集群数据hash分片算法Redis Cluster将所有数据划分为16384个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个key时，可以根据槽位定位算法定位到目标节点。 槽位定位算法Cluster默认会对 key值使用crc16算法进行 hash得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。HASH_SLOT &#x3D; CRC16(key) mod 16384再根据槽位值和Redis节点的对应关系就可以定位到key具体是落在哪个Redis节点上的。 八、Redis执行命令有死循环阻塞BugRANDOMKEY在随机拿出一个 key后，首先会先检查这个key是否已过期，如果该key已经过期，那么Redis 会删除它，这个过程就是惰性删除。但清理完了还不能结束，Redis还要找出一个没过期的 key，返回给客户端。此时，Redis则会继续随机拿出一个key，然后再判断它是否过期，直到找出一个没过期的key返回给客户端。 这里就有一个问题了，如果此时Redis 中，有大量key已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期key以及寻找不过期 key 上，导致的结果就是，RANDOMKEY 执行耗时变长，影响Redis性能。以上流程，其实是在master 上执行的。如果在slave 上执行RANDOMEKY，那么问题会更严重。slave自己是不会清理过期key，当一个key要过期时，master 会先清理删除它，之后master向slave发送一个DEL命令，告知slave 也删除这个key，以此达到主从库的数据一致性。假设Redis 中存在大量已过期还未被清理的 key，那在 slave上执行RANDOMKEY时，就会发生以下问题:1、slave随机取出一个key，判断是否已过期。2、key 已过期，但slave不会删除它，而是继续随机寻找不过期的key。3、由于大量key都已过期，那 slave就会寻找不到符合条件的 key，此时就会陷入死循环。也就是说，在slave 上执行RANDOMKEY，有可能会造成整个Redis 实例卡死。这其实是Redis 的一个Bug，这个 Bug一直持续到5.0才被修复，修复的解决方案就是在slave中最多找一定的次数，无论是否能找到，都会退出循环。 九、一次线上事故，Redis主从切换导致了缓存雪崩我们假设，slave的机器时钟比 master走得快很多。此时，Redis master里设置了过期时间的key，从 slave角度来看，可能会有很多在master里没过期的数据其实已经过期了。如果此时操作主从切换，把slave提升为新的master。它成为master后，就会开始大量清理过期key，此时就会导致以下结果: master大量清理过期key，主线程可能会发生阻塞，无法及时处理客户端请求。 Redis 中数据大量过期，引发缓存雪崩。 当master与slave机器时钟严重不一致时，对业务的影响非常大。所以，我们一定要保证主从库的机器时钟一致性，避免发生这些问题。 十、Redis持久化RDB、AOF、混合持久化RDB快照(snapshot)在默认情况下，Redis 将内存数据库快照保存在名字为dump.rdb的二进制文件中。你可以对Redis进行设置，让它在”N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据集。 比如说，以下设置会让Redis在满足” 60秒内有至少有1000个键被改动”这一条件时，自动保存一次数据集: #save 60 1000 &#x2F;&#x2F;关闭RDB只需要将所有的save保存策略注释掉即可 还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。 bgsave的写时复制(cOW)机制Redis 借助操作系统提供的写时复制技术（Copy-On-Wite, COW)，在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据。 save与bgsave对比： 命令 save bgsave IO类型 同步 异步 是否阻塞redis其他命令 是 否(在生成子进程执行调用fork函数时会有短暂阻塞) 复杂度 O(n) O(n) 优点 不会消耗额外内存 不会阻塞客户端命令 缺点 阻塞客户端命令 需要fork子进程，消耗内存 AOF (append-only file)快照功能并不是非常耐久(durable):如果Redis 因为某些原因而造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从1.1版本开始，Redis增加了一种完全耐久的持久化方式: AOF持久化，将修改的每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)你可以通过修改配置文件来打开AOF功能: #appendonly yes从现在开始，每当Redis 执行一个改变数据集的命令时(比如SET)，这个命令就会被追加到AOF文件的末尾。 这样的话，当Redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。你可以配置Redis多久才将数据fsync到磁盘一次。有三个选项: appendfsync always:每次有新命令追加到 AOF文件时就执行一次 fsync ,非常慢，也非常安全 appendfsync everysec:每秒 fsync一次，足够快，并且在故障时只会丢失1秒钟的数据。 appendfsync no:从不 fsync ,将数据交给操作系统来处理。更快，也更不安全的选择。 推荐（并且也是默认）的措施为每秒fsync一次，这种 fsync策略可以兼顾速度和安全性。 AOF重写AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件例如，执行了如下几条命令: 123456789101112127.0.0.1:6379&gt; incr readcount(integer) 1127.0.0.1:6379&gt; incr readcount(integer) 2127.0.0.1:6379&gt; incr readcount(integer) 3127.0.0.1:6379&gt; incr readcount(integer) 4127.0.0.1:6379&gt; incr readcount(integer) 5127.0.0.1:6379&gt; incr readcount(integer) 6 重写后AOF文件里变成 1234567*3$3SET$2readcount$16 如下两个配置可以控制AOF自动重写频率 12# auto-aof-rewrite-min-size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大# auto-aof-rewrite-percentage 100 //aof文件自上一次重写后文件大小增长了100%则再次触发重 当然AOF还可以手动重写，进入redis客户端执行命令bgrewriteaof重写AOF注意，AOF重写redis会fork出一个子进程去做(gyave命令类似)，不会对redis正常命令处理有太多影响 RDB和AOF对比： 命令 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 容易丢失数据 根据策略决定 生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。 Redis 4.0混合持久化重启Redis时，我们很少使用RDB来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重放，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis 实例很大的情况下，启动需要花费很长的时间。Redis 4.0为了解决这个问题，带来了一个新的持久化选项——混合持久化。通过如下配置可以开启混合持久化(必须先开启aof): #aof-use-rdb-preamble yes 如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫 appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在Redis重启的时候，可以先加载RDB的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率大幅得到提升。混合持久化AOF文件结构如下 十一、Redis线上数据如何备份1、写crontab定时调度脚本，每小时都copy一份rdb或aof文件到另外一台机器中去，保留最近48小时的备份 2、每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份3、每次copy备份的时候，都把太l旧的备份给删了 十二、Redis主从复制风暴​ 如果Redis主节点有很多从节点，在某一时刻如果所有从节点都同时连接主节点，那么主节点会同时把内存快照RDB发给多个从节点，这样会导致Redis主节点压力非常大，这就是所谓的Redis主从复制风暴问题。 这种问题我们对Redis主从架构做一些优化得以避免，比如可以做下面这种树形复制架构。","tags":["Redis"],"categories":["Redis"]},{"title":"SpringBoot","path":"/2023/03/31/SpringBoot/","content":"SpringBoot@SpringBootConfiguration@componentScan excludeFilters -用来在组件扫描时进行排除，也会排除自动配置类@EnableAutoConfiguration @AutoconfigurationPackage-用来记住扫描的起始包 @lmport(AutoConfigurationlmportSelector.class)用来加载 META-INF&#x2F;spring.factories中的自动配置类","tags":["SpringBoot"],"categories":["SpringBoot"]},{"title":"SpringMVC","path":"/2023/03/30/SpringMVC/","content":"SpringMVC一、SpringMVC执行流程初始化阶段: 在 Web容器第一次用到DispatcherServlet的时候，会创建其对象并执行init方法 init方法内会创建Spring Web容器，并调用容器refresh方法 refresh过程中会创建并初始化SpringMVC中的重要组件，例如MultipartResolver、HandlerMapping,HandlerAdapter，HandlerExceptionResolver、ViewResolver等 容器初始化后，会将上—步初始化好的重要组件，赋值给DispatcherServlet的成员变量，留待后用 匹配阶段: 用户发送的请求统一到达前端控制器 DispatcherServlet DispatcherServlet遍历所有HandlerMapping，找到与路径匹配的处理器 HandlerMapping有多个，每个HandlerMapping会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识@RequestMapping 的优先级最高心 对应@RequestMapping的处理器是HandlerMethod，它包含了控制器对象和控制器方法信息 其中路径与处理器的映射关系在HandlerMapping初始化时就会建立好 将HandlerMethod连同匹配到的拦截器，生成调用链对象HandlerExecutionChain返回 遍历HandlerAdapter处理器适配器，找到能处理HandlerMethod的适配器对象，开始调用 执行阶段: 执行拦截器preHandle 由HandlerAdapter 调用HandlerMethod 调用前处理不同类型的参数 调用后处理不同类型的返回值 第⒉步没有异常 ​ 返回ModelAndView ​ 执行拦截器postHandle方法 ​ 解析视图，得到View对象，进行视图渲染 第⒉步有异常，进入HandlerExceptionResolver异常处理流程 最后都会执行拦截器的afterCompletion方法 如果控制器方法标注了@ResponseBody 注解，则在第2步，就会生成json结果，并标记ModelAndView已处理，这样就不会执行第3步的视图渲染","tags":["SpringMVC"],"categories":["SpringMVC"]},{"title":"Spring","path":"/2023/03/20/Spring/","content":"一、Spring bean生命周期阶段1:处理名称，检查缓存 先把别名解析为实际名称，再进行后续处理 若要FactoryBean本身，需要使用&amp;名称获取 singletonObjects是一级缓存，放单例成品对象 singletonFactories是三级缓存，放单例工厂 earlySingletonObjects是二级缓存，放单例工厂的产品，可称为提前单例对象 阶段2:检查父工厂 父子容器的bean名称可以重复 优先找子容器的bean，找到了直接返回，找不到继续到父容器找 阶段3︰检查DependsOn阶段4:按Scope创建bean 创建singleton 创建prototype创建其它scope scope理解为从xxx范围内找这个bean更加贴切 singleton scope表示从单例池范围内获取bean，如果没有，则创建并放入单例池 prototype scope表示从不缓存bean，每次都创建新的 request scope表示从request对象范围内获取 bean，如果没有，则创建并放入request . 阶段5:创建bean 创建bean 实例 依赖注入 初始化 登记可销毁bean 判断依据 如果实现了DisposableBean或AutoCloseable接口，则为可销毁bean如果自定义了destroyMethod，则为可销毁bean 如果采用@Bean没有指定destroyMethod，则采用自动推断方式获取销毁方法名(close,shutdown)如果有@PreDestroy标注的方法 存储位置 singleton scope的可销毁bean会存储于beanFactory的成员当中自定义scope的可销毁bean 会存储于对应的域对象当中 prototype scope不会存储，需要自己找到此对象销毁 存储时都会封装为DisposableBeanAdapter类型对销毁方法的调用进行适配 阶段6:类型转换如果getBean的requiredType参数与实际得到的对象类型不同，会尝试进行类型转换 阶段7︰销毁bean singleton bean的销毁在ApplicationContext.close时，此时会找到所有DisposableBean的名字，逐一销毁 自定义scope bean的销毁在作用域对象生命周期结束时 prototype bean的销毁可以通过自己手动调用AutowireCapableBeanFactory.destroyBean方法执行销毁 同一bean中不同形式销毁方法的调用次序 优先后处理器销毁，即@PreDestroy 其次DisposableBean接口销毁 最后destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable接口多选一) 二、Spring事物失效的几种场景及原因 抛出检查异常导致事务不能正确回滚 原因: Spring默认只会回滚非检查异常 解法:配置rollbackFor属性 业务方法内自己try-catch异常导致事务不能正确回滚 原因:事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉 解法1:异常原样抛出 解法2:手动设置TransactionStatus.setRollbackOnly() aop切面顺序导致导致事务不能正确回滚 原因:事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常…解法:同情况2 非public方法导致的事务失效 原因: Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的 解法：改为public方法 父子容器导致的事务失效原因:子容器扫描范围过大，把未加事务配置的service扫描进来 解法1：各扫描各的，不要图简便解法2：不要用父子容器，所有bean放在同一容器 调用本类方法导致传播行为失效原因:本类方法调用不经过代理，因此无法增强 解法1:依赖注入自己(代理）来调用解法2:通过AopContext拿到代理对象，来调用 解法3:通过CTW, LTW 实现功能增强 @Transactional没有保证原子行为原因:事务的原子性仅涵盖insert、update、delete、select … for update语句select方法并不阻塞 @Transactional方法导致的synchronized 失效原因: synchronized保证的仅是目标方法的原子性，环绕目标方法的还有commit等操作，它们并未处于sync块内 解法1: synchronized范围应扩大至代理方法调用解法2:使用select … for update替换select 三、Spring的设计模式1.Spring中的Singleton Bean是否是单例模式?请大家区分singleton pattern 与Spring 中的 singleton bean 根据单例模式的目的 Ensure a class only has one instance, and provide a global point of access to it 显然Spring 中的 singleton bean并非实现了单例模式，singleton bean 只能保证每个容器内，相同id的bean单实例 当然Spring 中也用到了单例模式，例如 org.springframework.transaction.TransactionDefinition#withDefaults org.springframework.aop.TruePointcut#fINSTANCE org.springframework.aop.interceptor.ExposelnvocationInterceptor#ADVISOR 2.Spring中的 Builder​\tSeparate the construction of a complex object from its representation so that the same construction process can create different representations 它的主要亮点有三处:1．较为灵活的构建产品对象2．在不执行最后build方法前，产品对象都不可用 3.构建过程采用链式调用，看起来比较爽Spring中体现Builder模式的地方: org.springframework.beans.factory.support.BeanDefinitionBuilder org.springframework.web.util.UriComponentsBuilder org.springframework.http.ResponseEntity.HeadersBuilder org.springframework.http.ResponseEntity.BodyBuilder 3.Spring中的Factory Method​\tDefine an interface for creating an object, but let subclasses decide which class to instantiate. Factory Methodlets a class defer instantiation to subclasses 根据上面的定义，Spring中的ApplicationContext与BeanFactory 中的getBean都可以视为工厂方法，它隐藏了bean(产品）的创建过程和具体实现Spring 中其它工厂: org.springframework.beans.factory.FactoryBean @Bean标注的静态方法及实例方法 ObjectFactory 及 ObjectProvider 前两种工厂主要封装第三方的 bean的创建过程，后两种工厂可以推迟 bean创建，解决循环依赖及单例注入多例等问题 4.Spring 中的Adapter​\tConvert the interface of a class into another interface clients expect.Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces 典型的实现有两处: org.springframework.web.servlet.HandlerAdapter -因为控制器实现有各种各样，比如有大家熟悉的 @RequestMapping标注的控制器实现 传统的基于Controller接口(不是@Controller注解啊）的实现 较新的基于RouterFunction接口的实现 它们的处理方法都不一样，为了统一调用，必须适配为HandlerAdapter接口 org.springframework.beans.factory.support.DisposableBeanAdapter -因为销毁方法多种多样，因此都要适配为DisposableBean来统一调用销毁方法 5.Spring中的Composite​\tCompose objects into tree structures to represent part-whole hierarchies. Composite lets clients treatindividual objects and compositions of objects uniformly 典型实现有: org.springframework.web.method.support.HandlerMethodArgumentResolverComposite org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite org.springframework.web.servlet.handler.HandlerExceptionResolverComposite org.springframework.web.servlet.view.ViewResolverComposite composite对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用composite对象的接口方法时，其实是委托具体干活的实现来完成 6.Spring中的DecoratorAttach additional responsibilities to an object dynamically.Decorators provide a flexible alternative tosubclassing for extending functionality典型实现 org.springframework.web.util.ContentCachingRequestWrappe 7.Spring中的ProxyProvide a surrogate or placeholder for another object to control access to it装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问典型实现: org.springframework.aop.framework.JdkDynamicAopProxy. org.springframework.aop.framework.ObjenesisCglibAopProxy 8.Spring中Chain of ResponsibilityAvoid coupling the sender of a request to its receiver by giving more than one object a chance to handle threquest.Chain the receiving objects and pass the request along the chain until an object handles it典型实现 org.springframework.web.servlet.Handlerlnterceptor 9.Spring中的ObserverDefine a one-to-many dependency between objects so that when one object changes state, all its dependentsare notified and updated automatically典型实现: org.springframework.context.ApplicationListener org.springframework.context.event.ApplicationEventMulticaster org.springframework.context.ApplicationEvent 10.Spring 中的StrategyDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets thealgorithm vary independently from clients that use it典型实现 org.springframework.beans.factory.support.InstantiationStrategy org.springframework.core.annotation.MergedAnnotations.SearchStrategy org.springframework.boot.autoconfigure.condition.SearchStrategy 11.Spring中的Template MethodDefine the skeleton of an algorithm ini an operation, deferring some steps to subclasses. Template Method letssubclasses redefine certain steps of an algorithm without changingthe algorithm’s structure典型实现 大部分以Template命名的类，如JdbcTemplate,TransactionTemplate 很多以Abstract命名的类，如AbstractApplicationContext 最基本的切面是Advisor，一个Aspect切面对应一到多个Advisor 最基本的Advice是MethodInterceptor，其它Advice最终都将适配为MethodInterceptor创建代理的方式 实现了用户自定义接口，采用jdk动态代理没有实现用户自定义接口，采用cglib 代理 设置了setProxyTargetClass(true)，统一采用cglib 代理切面、切点、通知等不会被代理 AnnotationAwareAspectJAutoProxyCreator调用时机:创建阶段、依赖注入阶段、初始化阶段 四、循环依赖 单例set方法（包括成员变量）循环依赖，Spring 会利用三级缓存解决，无需额外配置 —级缓存存放成品对象 二级缓存存放发生了循环依赖时的产品对象（可能是原始bean，也可能是代理bean) 三级缓存存放工厂对象，发生循环依赖时，会调用工厂获取产品 Spring 期望在初始化时创建代理，但如果发生了循环依赖，会由工厂提前创建代理，后续初始化时就不必重复创建代理 二级缓存的意义在于，如果提前创建了代理对象，在最后的阶段需要从二级缓存中获取此代理对象，作为最终结果 构造方法及多例循环依赖解决办法 @Lazy @Scope ObjectFactory &amp; ObjectProvider Provider","tags":["Spring"],"categories":["Spring"]},{"title":"JAVA面试","path":"/2023/03/06/JAVA面试/","content":"JAVASE面试题算法篇一、查找二分查找 前提：有序数组 A 定义左边界L、右边界R，确定搜索范围，循环执行3、4步 获取中间索引 M &#x3D; （L+R）&#x2F;2 中间索引的值 A[M] 与待搜索的值 T 进行比较 A[M] &#x3D; T 表示找到，返回中间索引 A[M] &gt; T，中间值右侧的其他元素都大于T，无需比较，中间索引左边寻找，M - 1设置为右边界，重新查找 A[M] &lt; T，中间值左侧的其他元素都小于T，无需比较，中间索引右边寻找，M + 1设置为左边界，重新查找 当 L &gt; R 时，表示没有找到，结束循环 1234567891011121314public int binarySearch(int[] a,int t)&#123; int l = 0,r = a.length - 1,m; while(l &lt;= r)&#123; m = (l+r) / 2; if(a[m]==t)&#123; return m; &#125;else if(a[m] &gt; t)&#123; r = m - 1; &#125;else&#123; l = m + 1; &#125; &#125; return -1;&#125; 基础篇一、自增变量12345678910public static void main(String[] args) &#123; int i = 1; i = i++; int j = i++; int k = i + ++i * i++; System.out.println(&quot;i=&quot; + i); System.out.println(&quot;j=&quot; + j); System.out.println(&quot;k=&quot; + k); &#125;i=4,j=1,k=11 1执行 i = i++; 先将i变量压入操作数栈，然再对i变量进行自增,最后把计算结果赋值给 i , i 任然是1 小结 赋值&#x3D;，最后计算 &#x3D;右边的从左到右加载值依次压入操作数栈 实际先算哪个，看运算符优先级 自增、自减操作都是直接修改变量的值，不经过操作数栈 最后的赋值之前，临时结果也是存储在操作数栈中 二、类加载类加载过程分为三个阶段1.加载 将类的字节码载入方法区，并创建类.class 对象如果此类的父类没有加载，先加载父类 加载是懒惰执行 2.链接 验证–验证类是否符合Class规范，合法性、安全性检查 准备-为static变量分配空间，设置默认值 解析–将常量池的符号引用解析为直接引用 3.初始化 执行静态代码块与非final静态变量的赋值 初始化是懒惰执行 双亲委派所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器 能找到这个类，由上级加载，加载后该类也对下级加载器可见 找不到这个类，则下级类加载器才有资格执行加载 双亲委派的目的有两点 让上级类加载器中的类对下级共享（反之不行)，即能让你的类能依赖到jdk提供的核心类 让类的加载有优先次序，保证核心类优先加载 三、类初始化和实例初始化12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.classLoader;/** * 父类初始化&lt;clinit&gt; * 1、j = method() * 2、父类的静态代码块 * * 父类实例化方法: * 1、super()（最前） * 2、i = test() (9) * 3、父类的非静态代码块 (3) * 4、父类的无参构造（最后）(2) * * * 非静态方法前面其实有一个默认的对象this * this在构造器或&lt;init&gt; 他表示的是正在创建的对象，因为这里 * 是正在创建Son对象，所以test()执行的就是子类重写的代码(面 * 向对象多态) * * 这里i=test() 执行的就是子类重写的test()方法 */public class Father &#123; private int i = test(); private static int j = method(); static&#123; System.out.println(&quot;(1)&quot;); &#125; Father() &#123; System.out.println(&quot;(2)&quot;); &#125; &#123; System.out.println(&quot;(3)&quot;); &#125; public int test()&#123; System.out.println(&quot;(4)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(5)&quot;); return 1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.classLoader;/** * 子类的初始化&lt;clinit&gt; * 1、j = method() * 2、子类的静态代码块 * * 先初始化父类 (5)(1) * 初始化子类 (10) (6) * * 子类实例化方法: * 1、super()（最前） * 2、i = test() (9) * 3、子类的非静态代码块 (8) * 4、子类的无参构造（最后）(7) * * 因为创建了两个Son对象，因此实例化方法&lt;init&gt;执行两次 */public class Son extends Father &#123; private int i = test(); private static int j = method(); static &#123; System.out.println(&quot;(6)&quot;); &#125; Son() &#123; super();//写或不写，在子类构造器中一定会调用父类的构造器 System.out.println(&quot;(7)&quot;); &#125; &#123; System.out.println(&quot;(8)&quot;); &#125; public int test()&#123; System.out.println(&quot;(9)&quot;); return 1; &#125; public static int method() &#123; System.out.println(&quot;(10)&quot;); return 1; &#125; public static void main(String[] args) &#123; Son son = new Son(); System.out.println(); Son son1 = new Son(); &#125;&#125;//结果：//(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)//(9)(3)(2)(9)(8)(7) 类初始化过程 一个类要创建实例需要先加载并初始化该类 ​\tmain方法所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行()方法 ​\t()方法由静态类变量显示赋值代码和静态代码块组成 ​\t类变量显示赋值代码和静态代码块代码从上到下顺序执行 ​\t()方法只执行一次 实例初始化过程实例初始化就是执行()方法 ​\t()方法可能重载多个，有几个构造器就有几个()方法 ()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行 每次创建实例对象，调用对应构造器，执行的就是对应的()方法 ()方法的首行是super()或super(实参列表)，即对应父类的()方法 方法的重写1、哪些方法不可以被重写 ​\tfinal方法 ​\t静态方法 ​\tprivate等子类中不可见方法 2、对象的多态性 ​\t子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码 ​\t非静态方法默认的调用对象是this ​\tthis对象在构造器或者说方法中就是正在创建的对象 重写与重载的区别 名称 发生范围 方法名 形参列表 返回类型 修饰符 重写 父子类 必须一样 相同 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 子类方法不能缩小父类方法的访问范围 重载 本类 必须一样 类型，个数或者顺序至少有一个不同 无要求 无要求 四、对象引用类型 强引用 1普通变量赋值即为强引用，如A a &#x3D; new A(); 通过GC Root的引用链，如果强引用不到该对象，该对象才能被回收 软引用( SoftReference) 例如:SoftReference a &#x3D; new SoftReference(new A()); 如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象 软引用自身需要配合引用队列来释放 典型例子是反射数据 弱引用( WeakReference) 例如: WeakReference a &#x3D; new WeakReference(new A()); 如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象 弱引用自身需要配合引用队列来释放 典型例子是 ThreadLocalMap中的Entry 对象 虚引用(PhantomReference) 例如: PhantomReference a &#x3D; new PhantomReference(new A()); 必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源 典型例子是Cleaner释放DirectByteBuffer占用的直接内存 五、集合ArrayList1、扩容机制 ​\tArrayList() 会使用长度为零的数组 ​\tArrayList(int initialCapacity) 会使用指定容量的数组 ​\tArrayList(Collection&lt;? extends E&gt; c) 会使用c的大小作为数组容量 ​\tadd(Object o) 首次扩容为10，再次扩容为上次容量的1.5倍 ​\taddAll(Collection c)没有元素时，扩容为Math.max（10，c的长度），有元素时为Math.max（原容量的1.5倍，原容量加上c的长度） 12345678910111213if (minCapacity - elementData.length &gt; 0) grow(minCapacity);private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 2、fail-fast 与 fail-safe ​\tArrayList是fail-fast的典型代表，遍历的同时不能修改，尽快失败 ​\tCopyOnWriteArrayList 是fail-safe的典型代表，遍历的同时可以修改，原理是读写分离。 LinkedListArrayList 与 LinkedList ArrayList 基于数组，需要连续内存 随机访问快（指根据下标访问） 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，性能低 可以利用 cpu 缓存 LinkedList 基于双向链表，无需连续内存 随机访问慢（要沿着链表遍历） 头尾插入删除性能高 占用内存多 HashMap1、底层数据结构 ​\t1.7：数组+链表，头插法 ​\t1.8：数组+（链表|红黑树），尾插法 2、为何要用红黑树，为何一上来不树化，树化阈值为何是8，何时会树化，何时会退化为链表? ​\t红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况 ​\thash 表的查找，更新的时间复杂度是0(1)，而红黑树的查找，更新的时间复杂度是0(log n),TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表。 ​\thash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是0.00000006，选择8就是为了让树化几率足够小。 ​\t树化两个条件:链表长度超过树化阈值（8）;数组容量&gt;&#x3D;64​\t退化情况1:∶在扩容时如果拆分树时，树元素个数&lt;&#x3D;6则会退化链表，​\t退化情况2: remove树节点时，若root、root.left、root.right、root.left.left有一个为null，也会\t退化为链表 3、扩容：当容量大于数组容量的0.75时，2倍扩容 4、索引如何计算? hashCode都有了，为何还要提供 hash() 方法?数组容量为何是2的n次幂? ​\t① 计算对象的hashcode()，再进行调用 HashMap 的 hash()方法进行二次哈希，最后&amp; (capacity - 1)得到索引​\t② 二次hash()是为了综合高位数据，让哈希分布更为均匀​\t③ 计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高;扩容时 hash &amp; oldcap&#x3D;-0的元素留在原来位置，否则新位置&#x3D;旧位置+oldcap​\t④但①、②、③都是为了配合容量为2的n次幂时的优化手段，例如 Hashtable 的容量就不是2的n次幂，并不能说哪种设计更优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量 put方法①HashMap是懒惰创建数组的，首次使用才创建数组 ②计算索引(桶下标)③如果桶下标还没人占用，创建Node占位返回 ④如果桶下标已经有人占用 ①已经是TreeNode走红黑树的添加或更新逻辑 ②是普通Node,走链表的添加或更新逻辑，如果链表长 度超过树化阈值，走树化逻辑⑤返回前检查容量是否超过阈值，一旦超过进行扩容 ⑥不同 ①链表插入节点时，1.7是头插法，1.8是尾插法 ②1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容 ③1.8在扩容计算Node 索引时，会优化 加载因子为何默认是0.75f 在空间占用与查询时间之间取得较好的权衡 大于这个值，空间节省了，但链表就会比较长影响性能 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多 多线程下会有啥问题? 扩容死链（1.7) 数据错乱（1.7，1.8) key 能否为null，作为key的对象有什么要求? HashMap 的key可以为null，但Map的其他实现则不然 作为key的对象，必须实现 hashCode和equals，并且 key的内容不能修改(不可变) String对象的hashCode()如何设计的，为啥每次乘的是31目标是达到较为均匀的散列效果，每个字符串的hashCode足够独特 字符串中的每个字符都可以表现为一个数字，称为Si，其中i的范围是0~n- 1 散列公式为:S0 * 31^(n-1)+S1* 31^(n-2)+… Si * 31^(n-1-i) + … Sn-1*31^0 31代入公式有较好的散列特性，并且31 *h可以被优化为 即32 * h - h 即25 * h - h 即h &lt;&lt;5 -h 六、设计模式单例模式什么是单例模式？​ 单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。 要点 某个类只能有一个实例：构造器私有化 它必须自行创建这个实例：含有一个该类的静态变量来保存这个唯一的实例 它必须自行向整个系统提供这个实例：对外提供获取该实例对象的方式：(1）直接暴露（2）用静态变量的get方法获取 懒汉式：直接创建对象，不存在线程安全问题​\t直接实例化饿汉式（简洁直观） 123456789101112131415161718/** * 饿汉式： * 在类初始化时直接创建实例对象，不管你是否需要对象都会创建 * * (1)构造器私有化 * (2)自行创建，并且用静态变量保存 * (3)向外提供这个实例 * (4)强调这是一个单例，用final修饰 */public class HungrySingleton &#123; public static final HungrySingleton INSTANCE = new HungrySingleton(); private HungrySingleton()&#123; &#125;&#125; 枚举式（最简洁） 123456789package singleton.hungry;/** * 枚举类型：表示该类型的对象是有限的几个 * 我们可以限定为一个，就成了单例 */public enum EnumSingleton &#123; INSTANCE&#125; 静态代码块（适合复杂实例化） 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;import java.util.Properties;public class StaticCodeBlock &#123; public static final StaticCodeBlock INSTANCE; private String info; static &#123; try &#123; Properties pro = new Properties(); pro.load(StaticCodeBlock.class.getClassLoader().getResourceAsStream(&quot;singleton.properties&quot;)); INSTANCE = new StaticCodeBlock(pro.getProperty(&quot;info&quot;)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private StaticCodeBlock(String info)&#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; @Override public String toString() &#123; return &quot;StaticCodeBlock&#123;&quot; + &quot;info=&#x27;&quot; + info + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 懒汉式：延迟创建对象线程不安全（适用于单线程） 1234567891011121314151617181920/** * 懒汉式： * 延迟创建这个实例对象 * * （1）构造器私有化 * （2）用一个静态变量保存这个唯一的实例 * （3）提供一个静态方法，获取这个实例对象 */public class LazySingleton &#123; private static LazySingleton instance; private LazySingleton()&#123; &#125; public static LazySingleton getInstance()&#123; if(instance == null)&#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 线程安全（使用于多线程） 123456789101112131415161718192021222324/** * 懒汉式： * 延迟创建这个实例对象 * * （1）构造器私有化 * （2）用一个静态变量保存这个唯一的实例 * （3）提供一个静态方法，获取这个实例对象 */public class LazySingletonSynchronized &#123; private static volatile LazySingletonSynchronized instance; //volatile解决共享变量的可见性，有序性 private LazySingletonSynchronized()&#123; &#125; public static LazySingletonSynchronized getInstance()&#123; //双检锁 if (instance == null) &#123; synchronized (LazySingletonSynchronized.class) &#123; if (instance == null) &#123; instance = new LazySingletonSynchronized(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类（使用于多线程） 12345678910111213141516/** * 在内部类被加载和初始化时，才创建INSTANCE实例对象 * 静态内部类不会自动随着外部类的加载和初始化而初始化，它是单独去加载和初始化的。 * 因为是在内部类加载和初始化时创建，因此线程安全 */public class LazySingletonInnerclass &#123; private LazySingletonInnerclass()&#123; &#125; private static class Inner&#123; private static final LazySingletonInnerclass INSTANCE= new LazySingletonInnerclass(); &#125; public static LazySingletonInnerclass getInstance()&#123; return Inner.INSTANCE; &#125;&#125; 破坏单例 反射（枚举类不会破坏） 反序列化（①若重写readResolve方法，不会破坏。②枚举类也不会破坏） Unsafe()方法 小结​\t如果是饿汉式，枚举形式最简单 ​\t如果是懒汉式，静态内部类形式最简单 并发一、线程状态 二、线程池核心参数 1、corePoolSize 核心线程数目 ​\t最多保留的线程数 2、maximumPoolSize 最大线程数目 ​\t核心线程 + 救急线程 3、keepAliveTime 生存时间 ​\t针对救急线程 4、unit 时间单位 ​\t针对救急线程 5、workQueue ​\t阻塞队列 6、threadFactory 线程工厂 ​\t可以为线程创建时起个好名字 7、handler 拒绝策略 ​\t四种 三、sleep vs wait 共同点: wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态. 方法归属不同 sleep(long)是Thread 的静态方法 而wait(),wait(long)都是Object的成员方法，每个对象都有 醒来时机不同 执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来 wait(long)和 wait()还可以被notify 唤醒，wait()如果不唤醒就一直等下去 它们都可以被打断唤醒 锁特性不同 wait方法的调用必须先获取wait对象的锁，而sleep 则无此限制 wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃，但你们还可以用) 而sleep 如果在synchronized 代码块中执行，并不会释放对象锁（我放弃，你们也用不了) 四、lock vs synchronized 语法层面 synchronized 是关键字，源码在jvm中，用C++语言实现. Lock是接口，源码由jdk提供，用java语言实现 使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁 功能层面 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能 Lock 提供了许多synchronized不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量 Lock有适合不同场景的实现，如 ReentrantLock,ReentrantReadWriteLock 性能层面 在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能不赖 在竞争激烈时，Lock的实现通常会提供更好的性能 五、volatile保证线程安全 线程安全要考虑三个方面:可见性、有序性、原子性 可见性指，一个线程对共享变量修改，另一个线程能看到最新的结果 有序性指，一个线程内代码按编写顺序执行 原子性指，一个线程内多行代码以一个整体运行，期间不能有其它线程的代码插队 volatile 能够保证共享变量的可见性与有序性，但并不能保证原子性 六、悲观锁与乐观锁 悲观锁的代表是synchronized和Lock 锁 其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】 线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能 实际上，线程在获取synchronized和Lock锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会 乐观锁的代表是Atomiclnteger，使用cas来保证原子性 其核心思想是〔无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】 由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换 它需要多核cpu支持，且线程数不应超过cpu核数 七、Hashtable vs ConcurrentHashMap Hashtable 与 ConcurrentHashMap 都是线程安全的Map集合 Hashtable并发度低，整个Hashtable对应一把锁，同一时刻，只能有一个线程操作它 1.8之前ConcurrentHashMap使用了Segment +数组＋链表的结构，每个Segment对应一把锁，如果多个线程访问不同的Segment，则不会冲突 1.8开始ConcurrentHashMap将数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突 八、ThreadLocal ThreadLocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题 ThreadLocal同时实现了线程内的资源共享 其原理是，每个线程内有一个ThreadLocalMap类型的成员变量，用来存储资源对象 调用set方法，就是以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中 调用get方法，就是以ThreadLocal自己作为key，到当前线程中查找关联的资源值 调用remove方法，就是以ThreadLocal自己作为 key，移除当前线程关联的资源值 为什么ThreadLocalMap 中的 key (即ThreadLocal ）要设计为弱引用? Thread可能需要长时间运行〈如线程池中的线程)，如果key 不再使用，需要在内存不足（GC）时释放其占用的内存 但GC仅是让key的内存释放，后续还要根据key是否为null来进一步释放值的内存，释放时机有 a)\t获取key 发现null key b)\tset key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现null key有关 c)\tremove时(推荐），因为一般使用ThreadLocal时都把它作为静态变量，因此GC无法回收 虚拟机篇一、JVM 内存结构 线程私有 程序计数器 虚拟机栈 线程共享 堆、 方法区 哪些部分会出现内存溢出不会出现内存溢出的区域–程序计数器 出现OutOfMemoryError的情况 堆内存耗尽–对象越来越多，又一直在使用，不能被垃圾回收 方法区内存耗尽–加载的类越来越多，很多框架都会在运行期间动态产生新的类 虚拟机栈累积–每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时 出现StackOverflowError的区域 ​\t虚拟机栈内部 - 方法调用次数过多 方法区与永久代、元空间之间的关系 ​ 方法区是JVM规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等 ​ 永久代是Hotspot虚拟机对JVM规范的实现（1.8之前) ​ 元空间是Hotspot虚拟机对JVM规范的实现（1.8以后)，使用本地内存作为这些信息的存储空间 二、JVM 垃圾回收算法1、标记清除2、标记整理3、标记复制4、GC 和 分代回收算法​\tGC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度GC要点 ​\t回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法占用内存 判断无用对象，使用可达性分析算法，三色标记法标记存活对象，回收未标记对象 GC具体的实现称为垃圾回收器 GC大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略 根据GC的规模可以分成Minor GC,Mixed GC,Full Gc ​\t分代回收 伊甸园eden，最初对象都分配到这里，与幸存区合称新生代 幸存区survivor，当伊甸园内存不足，回收后的幸存对象到这里，分成from和to，采用标记复制算法 老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升) ​\tGC规模 Minor GC发生在新生代的垃圾回收，暂停时间短 Mixed GC新生代＋老年代部分区域的垃圾回收，G1收集器特有 Full GC新生代＋老年代完整垃圾回收，暂停时间长，应尽力避免 ​\tParallel GC eden内存不足发生Minor GC，标记复制STw old内存不足发生Full GC，标记整理STw 注重吞吐量 ​\tConcurrentMarkSweep Gc old并发标记，重新标记时需要STW，并发清除 Failback Full GC 注重响应时间 G1 Gc 响应时间与吞吐量兼顾 划分成多个区域，每个区域都可以充当eden,survivor, old, humongous 新生代回收: eden内存不足，标记复制STW 并发标记: old并发标记，重新标记时需要STw 混合收集:并发标记完成，开始混合收集，参与复制的有eden、survivor、old，其中old会根据暂停时间目标，选择部分回收价值高的区域，复制时STW Failback Full GC 5、内存溢出原因： 误用线程池导致的内存溢出 查询数据量太大导致的内存溢出 动态生成类导致的内存溢出 6、finalize方法非常不好，非常影响性能 非常不好 FinalizerThread是守护线程，代码很有可能没来得及执行完，线程就结束了，造成资源没有正确释放 异常被吞掉这个就太糟了，你甚至不能判断有没有在释放资源时发生错误 影响性能 重写了 finalize方法的对象在第一次被gc时，并不能及时释放它占用的内存，因为要等着FinalizerThread调用完finalize,把它从第一个unfinalized队列移除后，第二次gc时才能真正释放内存 可以想象gc本就因为内存不足引起，finalize调用又很慢（两个队列的移除操作都是串行执行的，用来释放连接类的资源也应该不快），不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多就会容易full gc, full gc后释放速度如果仍跟不上创建新对象的速度，就会OOM 质疑 有的文章提到【Finalizer线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread的优先级较普通线程更高，赶不上步伐的原因应该是finalize 执行慢等原因综合导致","tags":["JAVA面试"],"categories":["JAVA面试"]},{"title":"Little T","path":"/about/index.html","content":"Welcome To My Blog！！！欢迎来到我的博客！！！"}]